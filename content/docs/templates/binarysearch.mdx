---
title: Binary Search
description: Binary Search 101
full: true
---

import { Scrollycoding } from "@/components/scrollycoding"
import { CodeWithTooltips } from "@/components/codewithtooltips"

## Use Cases

| Use Case  | Description   | Example                                        |
|-----------|-------------|------------------------------------------------|
| Finding the First Occurrence of an Element  | Given a **sorted array** with duplicate elements, find the index of the first occurrence of a value. | In the array [1, 2, 2, 2, 3], the first index of 2 is 1. |
| Finding the First Element Greater Than or Equal to a Target | Find the smallest element in a sorted array that is **greater than or equal** to a given value.     | In the array [1, 3, 5, 7], for target 4, the lower bound returns index 2 (element 5). |
| Finding Insertion Points                    | Use the lower bound to determine the correct index for **inserting a new element** while maintaining sorted order. | In the array [1, 3, 5, 7], to insert 4, the lower bound returns 2, indicating 4 should be placed before 5. |


## Code Template


<Scrollycoding>

## !!steps Initializing search range

1. The element we are looking for is in the range `[left, right)`. *Note: the right boundary is not included.*
2. Use \< instead of \<= to prevent infinite loop


### !sticker

<CodeWithTooltips>

```python !code
def lower_bound(nums, target):
    # !tooltip[/right/] right
    left, right = 0, len(nums)
    # !tooltip[/</] small
    while left < right:
    	...
```

## !!tooltips right

The nums[right] is not accessable.

## !!tooltips small

Use \< instead of \<=

</CodeWithTooltips>

## !!steps Update search Range

3. Reduce the search range by half
4. Update the left or right boundary based on the valid() function. (The code template will return the first `valid` element)

### !sticker

<CodeWithTooltips>

```python !code
def lower_bound(nums, target):
    left, right = 0, len(nums)
    while left < right:
        # !tooltip[/mid/] mid
    	mid = left + (right - left) // 2
        if valid(nums[mid], target):
            right = mid
        else:
            left = mid + 1
    return left

def valid(num, target):
    ...

```

## !!tooltips mid

In Java and C++, be careful because there might be problems with integer overflow.

</CodeWithTooltips>


## !!steps Implenent Valid Function

5. Implenent valid function based on problem requirements.

### !sticker

<CodeWithTooltips>

```python !code
def lower_bound(nums, target):
    left, right = 0, len(nums)
    while left < right:
    	mid = left + (right - left) // 2
        if valid(nums[mid], target):
            right = mid
        else:
            left = mid + 1
    return left

def valid(num, target):
    return num >= target

```

</CodeWithTooltips>

</Scrollycoding>

## Issues and consideration
- **Return Value:** Decide what the function should return if the target value is not found. Common practices include returning the index of the first element greater than the target or returning a sentinel value (like -1)
- **Custom Comparators:** If using custom data types, ensure that the comparator correctly defines the ordering. This is crucial for the accuracy of the binary search.


## Related Problem
1. [69. Sqrt(x)](https://leetcode.com/problems/sqrtx/description/)
2. [278. First Bad Version](https://leetcode.com/problems/first-bad-version/description/)
2. [153. Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/)
2. [852. Peak Index in a Mountain Array](https://leetcode.com/problems/peak-index-in-a-mountain-array/description/)
2. [875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/description/)

## Resources
- [Binary Search Animated - Youtube](https://www.youtube.com/watch?v=eVuPCG5eIr4)
