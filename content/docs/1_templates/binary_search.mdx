---
title: Binary Search
description: Binary Search 101
full: true
---

import { Scrollycoding } from "@/components/scrollycoding"

## Use Cases

| Use Case  | Description   | Example                                        |
|-----------|-------------|------------------------------------------------|
| Finding the First Occurrence of an Element  | Given a **sorted array** with duplicate elements, find the index of the first occurrence of a value. | In the array [1, 2, 2, 2, 3], the first index of 2 is 1. |
| Finding the First Element Greater Than or Equal to a Target | Find the smallest element in a sorted array that is **greater than or equal** to a given value.     | In the array [1, 3, 5, 7], for target 4, the lower bound returns index 2 (element 5). |
| Finding Insertion Points                    | Use the lower bound to determine the correct index for **inserting a new element** while maintaining sorted order. | In the array [1, 3, 5, 7], to insert 4, the lower bound returns 2, indicating 4 should be placed before 5. |


## Code Template


<Scrollycoding>

## !!steps Initializing search range

1. The element we are looking for is in the range `[left, right)`. (right is not included.)
2. Use `<` instead of `<=` to prevent infinite loop


```python !code
# !mark(1:3) gold
def lower_bound(nums, target):
    left, right = 0, len(nums)
    while left < right:
```


## !!steps Update search Range

3. Calculates the midpoint index of a search interval to avoid overflow and ensure accurate indexing.
4. Update the left or right boundary based on the valid() function. (This code template will return the index of first `valid()` element)


```python !code
def lower_bound(nums, target):
    left, right = 0, len(nums)
    while left < right:
        # !mark(1:6) gold
    	mid = left + (right - left) // 2
        if valid(nums[mid], target):
            right = mid
        else:
            left = mid + 1
    return left
```


## !!steps Implenent Valid Function

5. Implenent valid function based on problem requirements.


```python !code
def lower_bound(nums, target):
    left, right = 0, len(nums)
    while left < right:
    	mid = left + (right - left) // 2
        if valid(nums[mid], target):
            right = mid
        else:
            left = mid + 1
    return left

# !mark(1:2) gold
def valid(num, target):
    return num >= target

```

</Scrollycoding>

## Issues and consideration
- **Return Value:** Decide what the function should return if the target value is not found. Common practices include returning the index of the first element greater than the target or returning a sentinel value (like -1)
- **Custom Comparators:** If using custom data types, ensure that the comparator correctly defines the ordering. This is crucial for the accuracy of the binary search.


## Related Problem
1. [69. Sqrt(x)](https://leetcode.com/problems/sqrtx/description/)
2. [278. First Bad Version](https://leetcode.com/problems/first-bad-version/description/)
2. [153. Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/)
2. [852. Peak Index in a Mountain Array](https://leetcode.com/problems/peak-index-in-a-mountain-array/description/)
2. [875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/description/)

## Resources
- [Binary Search Animated - Youtube](https://www.youtube.com/watch?v=eVuPCG5eIr4)
