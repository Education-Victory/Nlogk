---
title: Binary Search
description: Binary Search 101
full: true
---

import { Scrollycoding } from "@/components/scrollycoding"
import { CodeWithTooltips } from "@/components/codewithtooltips"

## Use Cases

| Use Case  | Description   | Example                                        |
|-----------|-------------|------------------------------------------------|
| Finding the First Occurrence of an Element  | Given a **sorted array** with duplicate elements, find the index of the first occurrence of a value. | In the array [1, 2, 2, 2, 3], the first index of 2 is 1. |
| Finding the First Element Greater Than or Equal to a Target | Find the smallest element in a sorted array that is **greater than or equal** to a given value.     | In the array [1, 3, 5, 7], for target 4, the lower bound returns index 2 (element 5). |
| Finding Insertion Points                    | Use the lower bound to determine the correct index for **inserting a new element** while maintaining sorted order. | In the array [1, 3, 5, 7], to insert 4, the lower bound returns 2, indicating 4 should be placed before 5. |


### Code Template


<Scrollycoding>

## !!steps Initializing search range

Binary Search 


### !sticker

<CodeWithTooltips>

```js !code
def lower_bound(nums, target):
    // !tooltip[/right/] right
    left, right = 0, len(nums)
    // !tooltip[/</] small
    while left < right:
    	...

```

## !!tooltips right

1. The possible results must be within the range [left, right)
2. The nums[right] is not accessable.

## !!tooltips small

1. The possible results must be within the range [left, right)
2. The nums[right] is not accessable.


</CodeWithTooltips>

## !!steps Update search Range

A Clash of Kings, the second book in the series, continues the epic saga. The Seven Kingdoms are plunged into war, with kings rising and falling. Meanwhile, Daenerys Targaryen seeks to return to Westeros with her growing dragons.

### !sticker

<CodeWithTooltips>

```js !code
def lower_bound(nums, target):
    left, right = 0, len(nums)
    while left < right:
    	mid = (left + right) // 2
        if valid(nums[mid], target):
            right = mid
        else:
            left = mid + 1
    return left

```

</CodeWithTooltips>


## !!steps Implenent Valid Function

Implenent valid function

### !sticker

<CodeWithTooltips>

```js !code
def lower_bound(nums, target):
    left, right = 0, len(nums)
    while left < right:
    	mid = (left + right) // 2
        if valid(nums[mid], target):
            right = mid
        else:
            left = mid + 1
    return left

def valid(num, target):
    return num >= target

```

</CodeWithTooltips>

</Scrollycoding>

## Fun facts

> Although the basic idea of binary search is comparatively straightforward, the details can be surprisingly tricky — Donald Knuth

When Jon Bentley assigned binary search as a problem in a course for professional programmers, he found that ninety percent failed to provide a correct solution after several hours of working on it, mainly because the incorrect implementations failed to run or returned a wrong answer in rare edge cases. A study published in 1988 shows that accurate code for it is only found in five out of twenty textbooks. Furthermore, Bentley's own implementation of binary search, published in his 1986 book Programming Pearls, contained an overflow error that remained undetected for over twenty years. The Java programming language library implementation of binary search had the same overflow bug for more than nine years. 

### Resources
- [Wikipedia - Binary_search](https://en.wikipedia.org/wiki/Binary_search#Implementation_issues)
